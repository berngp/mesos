/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.mesos;

import org.apache.mesos.Protos.*;

import java.util.List;


/**
 * Callback interface to be implemented by frameworks'
 * schedulers. Note that only one callback will be invoked at a time,
 * so it is not recommended that you block within a callback because
 * it may cause a deadlock.
 *
 * Each callback includes a reference to the scheduler driver that was
 * used to run this scheduler. The reference will not change for the
 * duration of a scheduler (i.e., from the point you do {@link
 * SchedulerDriver#start} to the point that {@link
 * SchedulerDriver#join} returns). This is intended for convenience so
 * that a scheduler doesn't need to store a reference to the driver
 * itself.
 *
 */
public interface Scheduler {
  /**
   * Invoked when the scheduler successfully registers with a Mesos
   * master. A unique ID (generated by the master) used for
   * distinguishing this framework from others and MasterInfo
   * with the ip and port of the current master are provided as arguments.
   *
   * @param driver      instance of the scheduler driver used to connect to Mesos.
   * @param frameworkId unique ID assigned to the framework.
   * @param masterInfo  description of the Mesos master.
   *
   * @see SchedulerDriver
   * @see FrameworkID
   * @see MasterInfo
   */
  void registered(SchedulerDriver driver,
                  FrameworkID frameworkId,
                  MasterInfo masterInfo);

  /**
   * Invoked when the scheduler re-registers with a newly elected Mesos master.
   * This is only called when the scheduler has previously been registered.
   * MasterInfo containing the updated information about the elected master
   * is provided as an argument.
   *
   * @param driver      instance of the scheduler driver used to connect to Mesos.
   * @param masterInfo  description of the Mesos master.
   *
   * @see SchedulerDriver
   * @see MasterInfo
   */
  void reregistered(SchedulerDriver driver, MasterInfo masterInfo);

  /**
   * Invoked when resources have been offered to this framework. A
   * single offer will only contain resources from a single slave.
   * Resources associated with an offer will not be re-offered to
   * _this_ framework until either (a) this framework has rejected
   * those resources (see {@link SchedulerDriver#launchTasks}) or (b)
   * those resources have been rescinded (see {@link offerRescinded}).
   * Note that resources may be concurrently offered to more than one
   * framework at a time (depending on the allocator being used). In
   * that case, the first framework to launch tasks using those
   * resources will be able to use them while the other frameworks
   * will have those resources rescinded (or if a framework has
   * already launched tasks with those resources then those tasks will
   * fail with a TASK_LOST status and a message saying as much).
   *
   * @param driver instance of the scheduler driver used to connect to Mesos.
   * @param offers list of resources available on a slave, each offer refers to
   *               one slave.
   *
   * @see SchedulerDriver
   * @see Offer
   */
  void resourceOffers(SchedulerDriver driver, List<Offer> offers);

  /**
   * Invoked when an offer is no longer valid (e.g., the slave was
   * lost or another framework used resources in the offer). If for
   * whatever reason an offer is never rescinded (e.g., dropped
   * message, failing over framework, etc.), a framwork that attempts
   * to launch tasks using an invalid offer will receive TASK_LOST
   * status updats for those tasks (see {@link #resourceOffers}).
   *
   * @param driver      instance of the scheduler driver used to connect to Mesos.
   * @param offerId    unique identifier of the offer.
   *
   * @see SchedulerDriver
   * @see OfferID
   */
  void offerRescinded(SchedulerDriver driver, OfferID offerId);

  /**
   * Invoked when the status of a task has changed (e.g., a slave is
   * lost and so the task is lost, a task finishes and an executor
   * sends a status update saying so, etc). Note that returning from
   * this callback _acknowledges_ receipt of this status update! If
   * for whatever reason the scheduler aborts during this callback (or
   * the process exits) another status update will be delivered (note,
   * however, that this is currently not true if the slave sending the
   * status update is lost/fails during that time).
   *
   * @param driver  instance of the scheduler driver used to connect to Mesos.
   * @param status  current status of ththee task.
   *
   * @see SchedulerDriver
   * @see TaskStatus
   */
  void statusUpdate(SchedulerDriver driver, TaskStatus status);

  /**
   * Invoked when an executor sends a message. These messages are best
   * effort; do not expect a framework message to be retransmitted in
   * any reliable fashion.
   *
   * @param driver      instance of the scheduler driver used to connect to Mesos.
   * @param executorId  framework generated ID to distinguish an executor. Only one
   *                    executor with the same ID can be active on the same slave at a
   *                    time.
   * @param slaveId     unique ID assigned to a slave.
   * @param data        message payload.
   *
   * @see SchedulerDriver
   * @see ExecutorID
   * @see SlaveID
   */
  void frameworkMessage(SchedulerDriver driver,
                        ExecutorID executorId,
                        SlaveID slaveId,
                        byte[] data);

  /**
   * Invoked when the scheduler becomes "disconnected" from the master
   * (e.g., the master fails and another is taking over).
   *
   * @param driver      instance of the scheduler driver used to connect to Mesos.
   * @see   SchedulerDriver
   */
  void disconnected(SchedulerDriver driver);

  /**
   * Invoked when a slave has been determined unreachable (e.g.,
   * machine failure, network partition). Most frameworks will need to
   * reschedule any tasks launched on this slave on a new slave.
   *
   * @param driver      instance of the scheduler driver used to connect to Mesos.
   * @param slaveId     unique ID assigned to a slave.
   *
   * @see SchedulerDriver
   * @see SlaveID
   */
  void slaveLost(SchedulerDriver driver, SlaveID slaveId);

  /**
   * Invoked when an executor has exited/terminated. Note that any
   * tasks running will have TASK_LOST status updates automagically
   * generated.
   *
   * @param driver      instance of the scheduler driver used to connect to Mesos.
   * @param executorId  framework generated ID to distinguish an executor. Only one
   *                    executor with the same ID can be active on the same slave at a
   *                    time.
   * @param slaveId     unique ID assigned to a slave.
   * @param status      indicate the state of the scheduler and executor driver.
   *
   * @see SchedulerDriver
   * @see ExecutorID
   * @see SlaveID
   * @see Status
   */
  void executorLost(SchedulerDriver driver,
                    ExecutorID executorId,
                    SlaveID slaveId,
                    int status);

  /**
   * Invoked when there is an unrecoverable error in the scheduler or
   * scheduler driver. The driver will be aborted BEFORE invoking this
   * callback.
   *
   * @param driver  instance of the scheduler driver used to connect to Mesos.
   * @param message the error message.
   *
   * @see SchedulerDriver
   */
  void error(SchedulerDriver driver, String message);
}
